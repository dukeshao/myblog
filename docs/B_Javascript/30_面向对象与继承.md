---
title: 面向对象与继承
date: 2015-10-03 23:18:33
tags: 
- Javascript
- 面向对象
- 继承
categories:
- B_Javascript
---

# 一、面向对象

## 概念oop

利用对象进行编程的一种思想。object-oriented programming，简称oop

## 创建对象

1.字面量

>  var obj={}

2.通过new关键字实例化对象

> var obj=new Object();

3.Object.create()

```

```

(1)工厂模式

在ECMAScript中是无法创建类的，开发人员就发明了一种函数，用函数来封装特定接口创建对象的细节。

```js
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    sayName = function () {
        alert(this.name);
    };
    return o;
}
var person1 = createPerson('zxj', 23, "Software Engineer");
```

缺点：没有解决对象识别的问题(得到的都是o对象，对象的类型都是Object)

(2)自定义构造函数（类的概念）

ECMAScript中的构造函数可以用来创建特定类型的对象。像Object和Array的原生的构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。

```js
function Student(name, age){
    this.name = name;
    this.age = age;
    this.sayName = function(){alert(this.name);};
}
var s1 = new Student("王铁锤", 18);

//可以通过控制台查看一下person1与s1的区别，更好理解。
//person1: 	__proto__ 直接指向对象 Object 的原型
//	s1: 	__proto__ 指向 Student 的原型 -> Student 的原型才指向对象 Object 的原型

//如此可以识别对象
```

## 构造函数与普通函数的区别

> 唯一区别：调用方式不同

- 任何函数，只要通过new操作符来调用，它就可以作为构造函数；
- 而任何构造函数，如果不通过new 操作符来调用，那它跟普通函数无区别。

> 约定：构造函数名首字母大写

## new 调用自定义构造函数,相当于执行了哪些步骤

* 创建一个新对象(在内部隐式调用了new Object())
* 将构造函数的作用域赋给新对象(把this绑定到实例对象)
* 执行构造函数中的代码(为这个新对象添加属性)
* 返回新对象

## this 的三种指向

* 函数名()： this指的是调用函数的当前对象
* ele.事件=函数名 ：this指的是ele
* new 函数名()： this为实例对象(new出来的对象)

# 二、对象的三大重要概念

(一)构造函数

* 每个函数都有一个prototype指向原型对象

(二)实例对象

* new 出来的对象就是实例对象,实例会复制构造函数内所有的属性和方法
* 可以实例对象获取原型对象

```
实例对象__proto__
```

(三)原型对象

* 每个函数都有一个prototype指向原型对象
* 原型对象默认包含一个constructor属性,指向构造函数
* 任何写在原型对象中的属性和方法,都可以让所有实例对象共享

## 判断原型和实例的关系（返回布尔值）

constructor: 得到构造函数的引用，一般用于判断该实例是否由某一构造函数生成

```
实例.constructor == Student //true
```

instanceof: 检测某个对象是不是某一构造函数的实例，适用于原型链中的所有实例

```
实例 instanceof Student //true
实例 instanceof Object //true
```

isPrototypeOf: 判断当前对象是否为实例的原型对象

```
原型对象.isPrototypeOf(实例) //true
```

# 三、解决方案

构造函数+原型对象

* 使用构造函数添加私有属性
* 使用原型对象添加共享方法

优点

* 实例对象都有自己的独有属性
* 实例共享了原型中的方法,最大限度的节省了内存
* 支持向构造函数传递参数

# 四、对象的属性特性(ES5对象扩展)

## 值属性的属性特性

* configurable

> 可配置性，控制着其描述的属性的修改，表示能否修改属性特性

* enumerable

> 可枚举性,表示能否通过for..in遍历得到属性

* writable

> 可写性, 表示能够修改属性的值

* value

> 数据属性,表示属性的值,默认值为undefined

obj.**创建属性, 默认值属性为true

Object.defineProperty(obj,proper)创建属性,默认值属性为false

## 与属性特性相关的方法

```
设置属性特性：
Object.defineProperty(obj, property, descriptor) 给对象的某个属性设置属性特性
Object.defineProperties(object, descriptors) 给对象的所有属性设置属性特性

获取属性特性：
Object.getOwnPropertyDescriptor(object, propertyname)

获取对象的所有属性：
Object.keys(object) 只获取到可枚举的属性
Object.getOwnPropertyNames(object) 获取所有属性的名称（包含不能枚举的属性）
```

```
var obj = {
    a:1,
    b:"lemon"
}
//1.给对象添加一个属性，同时设置属性特性。此时其他的属性特性不设置默认都为false。
//即configurable为false，不可以修改属性特性。
//即enumerable为false，不可以枚举
//即writable为false，不可写，不可以修改属性值
Object.defineProperty(obj,"c",{value:"laoxie"})； //以上属性特性均可改成true，实现相应的功能。

// 2.同时修改多个属性特性
Object.defineProperties(obj, {
    b:{value:'css4',enumerable:false},
    c:{writable:true}  //报错，因为上面定义该属性的configurable为false，意思是不可以修改属性特性
})

//建议：用传统方式添加属性，利用defineProperty修改属性特性（configurable为true的前提下）
```

## 对象属性的遍历与判断

* for…in

遍历对象中的所有可枚举属性, 无论该属性存在于实例中还是原型中

* in

```
if(name in s1){
	//只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中
}
```

* 对象.hasOwnProperty(属性)
    * 检测一个属性是存在于对象本身中
    * 返回true，说明属性存在对象中
    * 返回false，说明属性不存在或在原型中

> 检测一个属性是否存在于原型中：!obj.hasOwnProperty(name) && (name in obj) 

# 五、原型对象

## 重置原型对象

重置原型对象，可以一次性给原型对象添加多个方法，但切断了与原来原型对象的联系

```
function Popover(){}
Popover.prototype = {
    show:function(){},
    hide:function(){}
}
//- 注意覆盖问题（系统的原型对象不建议重写）
//- 注意识别问题（不可枚举性）
Object.defineProperty(Popover.prototype,"constructor",{value:"Popover",configurable:true})；
```

## 内置的原型对象

使用内置原型可以给已有构造函数添加方法

- 数组/字符串/数字等方法调用原理
- 扩展内置方法

```
if(!Array.prototype.norepeat){
    Array.prototype.norepeat = function(){
        return Array.from(new Set(this)); // this：指向实例arr
	}
}
```

# 六、原型链

实例与Object原型对象之间的链条称为原型链

* 原型模式的访问机制（原型搜索机制)

> 读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值；

>  如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值

> 如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）；

> 如果在Object的原型对象中还搜索不到，则抛出错误；

# 七、继承

继承是面向对象中一个非常重要的特征。指的是：子类继承父类的属性和方法。

> 我们可以通过继承的方式, 在父类的属性和方法基础上, 让子类也拥有这些属性和方法, 并可以扩展。

## 继承的好处:

1. 子类拥有父类所有的属性和方法（代码复用）；
2. 子类可以扩展自己的属性和方法（更灵活）；
3. 子类可以重写父类的方法

## 原型链继承

- 核心：拿父类实例来充当子类原型对象
- 缺点：
    - 无法操作父类构造函数的属性

```
function Person(name,age,gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
Person.prototype = {
    say(){console.log(`大家好，我叫${this.name}，欢迎跟大家交朋友`)}  
}
Object.defineProperty(Person.prototype,'constructor',{
    configurable:true,
    value:Person
});
let lemon = new Person('lemon',32,'女');
//===============原型链继承==========
function Man(name,age){
}
Man.prototype = new Person();
let laoxie = new Man('laoxie',18);
```

## 借用构造函数

核心：借父类的构造函数来增强子类实例，相当于把父类的实例属性复制一份给子类实例

- call：

    - 格式：父类构造函数.call(子类实例,参数1,参数2,参数3...)

- apply：

    - 格式：父类构造函数.apply(子类实例,[参数1,参数2,参数3...])
        call与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组

        ```
        //aplly用法：借用方法
        var arr = [20,2,40,33,21,8,22,46,32]
        Math.max.apply(null,arr)
        ```

## 组合继承

由于以上继承方法的缺点，实际开发中不可能单纯的只使用一种继承方法，而是利用它们的优点，规避它们的缺点，所以就有了组合继承法

- 继承属性：借用构造函数
    - 只在构造函数中定义属性
- 继承方法：原型链继承
    - 把所有的方法写入原型对象

**组合继承是最常用的继承模式。**

- 缺点（原型链继承法的缺点）：
    - 在原型对象中生成多余的属性
    - 多次执行父类构造函数

```
//原型链继承基础上补充借用构造函数
function Man(name,age){
    Person.call(this,name,age,'男');
}
```

## 原型式继承

- 核心：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例

- 解决原型链继承法的缺点：生成多余的属性

    ```
    function object(o){
        function F(){}
        F.prototype = o;
        return new F();
    }
    Man.prototype = object(Person.prototype);
    ```

ES5版本的原型式继承：Object.create()

## 寄生组合继承法

完美的继承方法

- 核心：
    - 继承属性：借用构造函数
    - 继承方法：原型式继承

## ES6继承

* class定义类
    * 写在类里面的方法实际是给Person.prototype添加方法
    * constructor方法是类的默认方法，相当于在构造函数内生成属性

```
//定义类
class Person {
    constructor(name,age) {
        this.name = name;
        this.age = age;
    }
    getInfo() {
         return `我叫${this.name},今年${this.age}岁`;;
    }
}
```

* extends实现继承
    * 子类继承了父类，在子类构造函数中必须调用super方法。
    * 子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。

```
// class 子类 extends 父类{}
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

class Man extends Person {
    constructor(name, age, gender) {
        //this.gender = gender; // 报错
        super(name, age);
        this.gender = gender; // 正确
    }
}   
```



3.注意

* 子类继承了父类,在子类constructor中必须调用super方法

* 没有调用super之前,不能使用this关键字

4.static 静态方法

如果在一个方法前，加上static关键字，这就称为“静态方法”

- 静态方法不会被实例继承，而是直接通过类来调用`Person.getInfo()`

- 父类的静态方法，可以被子类继承`Man.getInfo()`

    ```
    class Person{
        constructor(name,age,gender){
            this.name = name;
            this.age = age;
            this.gender = gender;
        }
        // 此处的方法写入原型对象中
        say(){console.log(大家好,我叫${this.name})}；
        static eat(){console.log('我是吃货');}
    }
    let lemon = new Person('lemon',32,'女');
    // 继承方法
    class Man extends Person{
        constructor(name,age){
            // 继承属性
            super(name,age,'男');
            this.hobby = ['吃','喝'];
        }
    }
    let laoxie = new Man('laoxie',18);
    ```

# 九、bind、call、apply

1.bind(对象)

改变函数的this指向,同时返回一个新函数

2.call(对象,参数1,参数2)

改变函数的this指向,并且执行该函数

3.apply(对象,[参数1,参数2])

* 改变函数的this指向,并且执行该函数

* apply(null,arr)表示不改变this的指向

* 允许通过数组将实参传递给形参

应用：

> 求数组中最大数和最小数
>
> ​	Math.max()
>
> ​	Math.min()

>  类数组使用Map 使用本不是自己的方法

>  判断数据类型, (自己有这个方法,但是想使用别人的这个方法)

Object.prototype.toString 判断引用数据类型的具体类型

# 十、闭包

1.闭包：定义在一个函数内部的函数

闭包是这样一种机制: 函数嵌套函数, 内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回.

这里涉及到几个概念:

1. 函数嵌套函数
2. 作用域(全局变量和局部变量)
    变量的访问规则
3. 垃圾回收机制(garbage collection)
    js内部不断扫描内存,并清理无引用对象(自动完成);

2.好处

1. 可以让一个变量长期驻扎在内存当中不被释放
2. 避免全局变量的污染, 和全局变量不同, 闭包中的变量无法被外部使用
3. 私有成员的存在, 无法被外部调用, 只可以自己内部使用

> 结论：

- 闭包是指有权访问另一函数作用域中的变量的函数
- 闭包，可以访问函数内部的局部变量，并让其长期驻留内存
- 由于闭包会携带包含它的作用域(运行环境)，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。

3.缺点：由于闭包会携带包含它的作用域(运行环境),因此会比其他函数占用更多内存,过度使用闭包可能造成性能问题