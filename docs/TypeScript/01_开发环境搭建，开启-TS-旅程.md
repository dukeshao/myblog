---
title: 01_开发环境搭建，开启 TS 旅程
categories: C_TypeScript
date: 2019-10-27 14:49:31
tags:
---

## 初始化项目

```js
//创建目录并进入
mkdir ts_app
cd ts_app
//使用npm 初始化项目
npm init -y

//创建以下文件夹
src：用来存放项目的开发资源，在 src 下创建如下文件夹：
	utils：和业务相关的可复用方法
    tools：和业务无关的纯工具函数
    assets：图片字体等静态资源
    api：可复用的接口请求方法
    config：配置文件
typings：模块声明文件
build：webpack 构建配置

//全局安装 typescript
npm install typescript -g

//安装成功后进入项目根目录，使用 typescript 进行初始化
tsc --init
```

tsconfig.json 里默认有 4 项没有注释的配置，有一个需要提前讲下，就是"lib"这个配置项，他是一个数组，他用来配置需要引入的声明库文件，我们后面会用到ES6语法，和DOM相关内容，所以我们需要引入两个声明库文件，需要在这个数组中添加"es6"和"dom"，也就是修改数组为<code>[“dom”, “es6”]</code>，其他暂时不用修改，接着往下进行。

```js
 //因为我们要搭配使用 webpack 进行编译和本地开发，不是使用 tsc 指令，所以要在项目安装一下
 npm i typescript
```

## 配置 TSLint

```js
// 首先需要在全局安装 TSLint，记着要用管理员身份运行
npm i tslint -g
//然后在我们的项目根目录下，使用 TSLint 初始化我们的配置文件,生成 tslint.json 文件
tslint -i
```

```js
//tslint.json
{
  "defaultSeverity": "error",
  "extends": [
    "tslint:recommended"
  ],
  "jsRules": {},
  "rules": {},
  "rulesDirectory": []
}
```

```
defaultSeverity是提醒级别，如果为error则会报错，如果为warning则会警告，如果设为off则关闭，那TSLint就关闭了；
extends可指定继承指定的预设配置规则；
jsRules用来配置对.js和.jsx文件的校验，配置规则的方法和下面的rules一样；
rules是重点了，我们要让TSLint根据怎样的规则来检查代码，都是在这个里面配置，比如当我们不允许代码中使用eval方法时，就要在这里配置"no-eval": true；
rulesDirectory可以指定规则配置文件，这里指定相对路径。
```

## 配置 webpack

接下来我们要搭配使用 webpack 进行项目的开发和打包，先来安装 webpack、webpack-cli、webpack-dev-server

```js
npm install webpack webpack-cli webpack-dev-server -D
```

我们将它们安装在项目中，并且作为开发依赖安装。接下来添加一个 webpack 配置文件，放在 build 文件夹下，我们给这个文件起名 webpack.config.js，然后在 package.json 里指定启动命令：

```json
{
  "scripts": {
    "start": "cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js"
  }
}
```

这里我们用到一个插件"cross-env"，并且后面跟着一个参数 NODE_ENV=development，这个用来在 webpack.config.js 里通过 process.env.NODE_ENV 来获取当前时开发环境还是生产环境，这个插件要安装：

```js
npm i cross-env
```

```js
//webpack.config.js

const HtmlWebpackPlugin = require("html-webpack-plugin");
const {CleanWebpackPlugin} = require("clean-webpack-plugin");

module.exports = {
  // 指定入口文件
  // 这里我们在src文件夹下创建一个index.ts
  entry: "./src/index.ts",
  // 指定输出文件名
  output: {
    filename: "main.js"
  },
  resolve: {
    // 自动解析一下拓展，当我们要引入src/index.ts的时候，只需要写src/index即可
    // 后面我们讲TS模块解析的时候，写src也可以
    extensions: [".tsx", ".ts", ".js"]
  },
  module: {
    // 配置以.ts/.tsx结尾的文件都用ts-loader解析
    // 这里我们用到ts-loader，所以要安装一下
    // npm install ts-loader -D
    rules: [
      {
        test: /\.tsx?$/,
        use: "ts-loader",
        exclude: /node_modules/
      }
    ]
  },
  // 指定编译后是否生成source-map，这里判断如果是生产打包环境则不生产source-map
  devtool: process.env.NODE_ENV === "production" ? false : "inline-source-map",
  // 这里使用webpack-dev-server，进行本地开发调试
  devServer: {
    contentBase: "./dist",
    stats: "errors-only",
    compress: false,
    host: "localhost",
    port: 8089
  },
  // 这里用到两个插件，所以首先我们要记着安装
  // npm install html-webpack-plugin clean-webpack-plugin -D
  plugins: [
    // 这里在编译之前先删除dist文件夹
    new CleanWebpackPlugin({
      cleanOnceBeforeBuildPatterns: ["./dist"]
    }),
    // 这里我们指定编译需要用模板，模板文件是./src/template/index.html，所以接下来我们要创建一个index.html文件
    new HtmlWebpackPlugin({
      template: "./src/template/index.html"
    })
  ]
};
```

## 开启服务

```js
npm run start
```

 开启成功后，我们可以在 index.ts 中写一些逻辑

```ts
// index.ts
let a: number = 123;

const h1 = document.createElement("h1");
h1.innerHTML = "Hello, I am Duke";
document.body.appendChild(h1);
```

 保存代码时，服务器会自动重新编译代码，并且浏览器会刷新

我们再来配置一下打包命令，添加 build 命令

```json
//package.json
{
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "cross-env NODE_ENV=development webpack-dev-server --mode=development --config ./build/webpack.config.js",
    "build": "cross-env NODE_ENV=production webpack --mode=production --config ./build/webpack.config.js"
  }
}
```

通过`npm run build`命令实现打包