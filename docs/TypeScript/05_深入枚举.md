---
title: 05_深入枚举
categories: C_TypeScript
date: 2019-10-27 14:52:20
tags:
---

## 基础用法

```tsx
enum duke{
	name,
	age
}
console.log(duke.name,duke.age);	// 0 1
```

如果某个字段使用了计算值或常量，那么该字段后面紧接着的字段必须设置初始值

```tsx
const getValue = () => {
  return 0;
};
enum ErrorIndex {
  a = getValue(),
  b, // error 枚举成员必须具有初始化的值
  c
}
enum RightIndex {
  a = getValue(),
  b = 1,
  c
}
const Start = 1;
enum Index {
  a = Start,
  b, // error 枚举成员必须具有初始化的值
  c
}
```

## 反向映射

只支持数字枚举，不支持字符串枚举

```tsx
enum Status{
    Success=200,
    NotFound=404,
    Error=500
}
console.log(Status["Success"]);	//200
console.log(Status[200]);	//"Success"
console.log(Status[Status["Success"]]);	//"Success"
```

TS 中定义的枚举，在编译后其实是对象

```js
{
    200: "Success",
    404: "NotFound",
    500: "Error",
    Error: 500,
    NotFound: 404,
    Success: 200
}
```

## 字符串枚举

字符串枚举值要求每个字段的值都必须是字符串字面量，或者是该枚举值中另一个字符串枚举成员

```tsx
enum Message {
  Error = "Sorry, error",
  Success = "Hoho, success"
}
console.log(Message.Error); // 'Sorry, error'
```

```tsx
enum Message {
  Error = "error message",
  ServerError = Error,
  ClientError = Error
}
console.log(Message.Error); // 'error message'
console.log(Message.ServerError); // 'error message'
```

注意：这里的其他枚举成员指的是同一个枚举值中的枚举成员，因为字符串枚举不能使用常量或者计算值，所以也不能使用其他枚举值中的成员

## 异构枚举

简单来说异构枚举就是枚举值中成员值既有数字类型又有字符串类型

```tsx
enum Result{
    Faild=0,
    Success="Success"
}
```

 不建议使用，因为往往我们将一类值整理为一个枚举值的时候，他们的特点是相似的，比如我们在做接口请求时的返回状态码，如果是状态码都是数字，如果是提示信息，都是字符串，所以在使用枚举的时候，往往是可以避免使用异构枚举的，重点是做好类型的整理

## 枚举成员类型和联合枚举类型

如果枚举值里所有成员的值都是字面量类型的值，那么这个枚举的每个成员和枚举值本身都可以作为类型来使用

### 1.枚举成员类型

```tsx
enum Animal{
    Dog=1,
    Cat=2
}
interface Dog{
    type:Animal.Dog;
    //这里使用 Animal.Dog 作为类型，指定接口 Dog的必须有一个 type 字段，且类型为 Animal.Dog
}
interface Cat{
    type:Animal.Cat
}
let cat:Cat={
    type:Animal.Dog	//error [ts]不能将类型 Animal.Dog 分配给类型 Animal.Cat
}
let dog:Dog={
    type:Animal.Dog
}
```

### 2.联合枚举类型

当我们的枚举值符合条件时，这个枚举值就可以看做是一个包含所有成员的联合类型

```tsx
enum Status{
    Off,
    On
}
interface Light{
    status:Status
}
enum Animal{
    Dog=1,
    Cat=2
}
const light1:Light={
    status:Animal.Dog	//error 不能将类型 Animal.Dog 分配给类型 Status
}
const light2:Light={
    status:Status.Off
}
const light3:Light={
    status:Status.On
}
```

上面例子定义接口 Light 的 status 字段的类型为枚举值 Status，那么此时 status 的属性值必须为 Status.Off 或 Status.On 中的一个，也就是相当于`status:Status.Off | Status.On`

## 运行时的枚举

枚举在编译后实际是一个对象，所以我们可以将枚举当做一个对象来使用

```tsx
enum E{
    A,
    B
}
const getIndex=(enumObj:{A:number}):number=>{
    return enumObj.A
}
console.log(getIndex(E));	//0
```

## const enum

枚举值在编译成 JS 会创建一个对应的对象，如果我们使用枚举只是为了让程序可读性好，并不需要编译后的对象，使用 `const enum` 定义枚举即可，这样编译后的代码不会创建这个对象，只是会从枚举里拿到相应的值进行替换

```tsx
enum Status{
    Off,
    On
}
const enum Animal{
    Dog,
    Cat
}
const status = Status.On;
const animal = Animal.Dog;
```

编译后

```js
var Status;
(function(Status){
    Status[(Status["Off"]=0)]="Off";
    Status[(Status["On"]=1)]="On";
})(Status || (Status={}));
var status=Status.On;
var animal = 0;	//Dog
```


