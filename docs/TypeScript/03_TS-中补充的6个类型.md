---
title: 03_TS 中补充的6个类型
categories: C_TypeScript
date: 2019-10-27 14:50:36
tags:
---


## tuple元组

元组可以看做是数组的拓展，它表示已知元素数量和类型的数组，是已知数组中每一个位置上的元素的类型

```tsx
let tuple: [string, number, boolean];
tuple = ["a", 2, false];

// error 不能将类型“number”分配给类型“string”。 不能将类型“string”分配给类型“number”。
tuple = [2, "a", false];

// error Property '2' is missin03g in type '[string, number]' but required in type '[string, number, boolean]'
tuple = ["a", 2];
```

上面我们定义了一个元组 tuple，它包含三个元素，且每个元素的类型是固定的，当我们为 tuple 赋值时，各个位置上的元素类型都要对应，元素个数也要一致

我们还可以给单个元素赋值：tuple[1]=3;

当我们访问元组中元素时，TS 会对我们在元素上做的操作进行检查

```tsx
tuple[0].split(":"); // right 类型"string"拥有属性"split"
tuple[1].split(":"); // error 类型“number”上不存在属性“split”
```

## enum 枚举

`enum`类型在 C++这些语言中比较常见，TS 在 ES 原有类型基础上加入枚举类型，是我们在 TS 中也可以给一组数值赋予名字，这样对开发者来说较为友好。比如我们要定义一组角色，每一个角色用一个数字代表，就可以使用枚举类型来定义：

```tsx
enum Roles {
  SUPER_ADMIN,
  ADMIN,
  USER
}
```

 上面定义的枚举类型 Roles 里面有三个值，TS 会为他们每个值分配编号，默认从0开始，依次排列，所以他们对应的值是

```tsx
enum Roles {
  SUPER_ADMIN = 0,
  ADMIN = 1,
  USER = 2
}
```

当我们使用的时候，就可以使用名字而不需要记数字和名称的对照关系了

```tsx
const superAdmin = Roles.SUPER_ADMIN;
console.log(superAdmin); // 0
```

也可以赋值不同的、不按顺序排列的值

```tsx
enum Roles {
  SUPER_ADMIN = 1,
  ADMIN = 3,
  USER = 7
}
```

也可以通过它对应的值1，获取它的名字

```tsx
console.log(Roles[3]); // 'ADMIN'
```

## Any 任意类型

```tsx
let value: any;
value = 123;
value = "abc";
value = false;

const array: any[] = [1, "a", true];
```

但是请注意，不要滥用 any，如果任何值都指定为 any 类型，那么 TS 将失去它的意义

所以如果类型是未知的，更安全的做法是使用 unknown 类型

## viod 无类型

void 和 any 相反，表示没有任意类型，就是什么类型都不是，这在我们定义函数，函数没有返回值时会用到：

```tsx
const consoleText = (text: string): void => {
  console.log(text);
};
```

void 类型的变量只能赋值为 undefined 和 null ，其他类型不能赋值给 void 类型的变量

## never

never 类型指那些永不存在的值的类型，它是那些总会抛出异常或根本不会有返回值的函数表达式的返回值类型，当变量被永不为真的类型保护所约束时，该变量也是 never 类型

```tsx
const errorFunc = (message:string):never=>{
    throw new Error(message);
}
```

这个 errorFunc 函数总是会抛出异常，所以它的返回值类型是 never，用来表明它的返回值是用不存在的

```tsx
const infiniteFunc = ():never=>{
    while(true){}
}
```

`infiniteFunc`也是根本不会有返回值的函数，它和之前讲 void 类型时的`consoleText`函数不同，`consoleText`函数没有返回值，是我们在定义函数的时候没有给他返回值，而`infiniteFunc`是死循环是根本不会返回值的，所以它们二者还是有区别的。

never 类型是任何类型的子类型，所以它可以赋值给任何类型；而没有类型是 never 的子类型，所以除了它自身没有任何类型可以赋值给 never 类型，any 类型也不能赋值给 never 类型

```tsx
let neverVar=(()=>{
	while(true){}
})();
neverVar = 123;//error 不能将类型"number"分配给类型"never"
```

## unknown 未知类型

`unknown`类型是 TS 在3.0版本新增的类型，它表示未知的类型，"unknown 相对于 any 是安全嗯"，当我们不确定它的类型的时候，可以指定是 any 类型，但是指定了 any 类型之后，这个值基本上是"废"了，你可以随意对它进行属性方法的访问，不管有的还是没有的，可以把它当做任意类型的值来使用，这往往会产生问题

```tsx
let value:any;
console.log(vlaue.name);
console.log(vlaue.toFixed);
console.log(value.length);
```

上面这些语句都不会报错，因为 value 是 any 类型，所以后面三个操作都有合法的情况；而当你指定值为 unknown 类型的时候，如果没有通过基于控制流的类型断言来缩小范围的话，是不能对他进行任何操作的，unknown 类型的值不是可以随意操作的

## 拓展

### 交叉类型

交叉类型就是取多个类型的并集，使用&符号定义，被&链接的过个类型构成一个交叉类型，表示这个类型同事具备这几个连接起来的类型的特点

```js
const merge=<T,U>(arg1:T,arg2:U):T & U =>{
    // 这里指定返回值的类型兼备T和U两个类型变量代表的类型的特点;
	let res = <T & U>{};
    // 这里使用Object.assign方法，返回一个合并后的对象；
    res = Object.assign(arg1,arg2);
    return res;
}
const info1={
    name:"duke"
}
const info2={
    age:18
}
const dukeinfo=merge(info1,info2);
console.log(dukeinfo.address);
//error 类型“{ name: string; } & { age: number; }”上不存在属性“address”
```

### 联合类型

联合类型实际是几个类型的结合，但是和交叉类型不同，联合类型是要求只要符合联合类型中任意一种类型即可，它使用`|`符号定义。

当我们的程序具有多样性，元素类型不唯一时，即使用联合类型

```tsx
const getLength=(content:string|number):number=>{
    if(typeof content === "string"){
        return content.length
    }else{
        return content.toString().length;
    }
}
console.log(getLength("abc"))//3
console.log(getLength(123))//3
```