---
title: 11_TS 中的类
categories: C_TypeScript
date: 2019-10-27 14:55:23
tags:
---

##基础

```tsx
class Parent{
    name:string;
    constructor(name:string){
        this.name=name;
    }
}
class Child extends Parent{
    constructor(name:string){
        super(name);
    }
}
```

## 修饰符

#### 1.public 公共修饰符

`public`表示公有的，用来指定在创建实例后可以通过实例访问的，也就是类定义的外部可以访问的属性和方法。默认是 public，但是 TSLint 可能会要求你必须用修饰符来表明这个属性或方法是什么类型

```tsx
class Point{
    public x:number;
    public y:number;
    constructor(x:number,y:number){
        this.x=x;
        this.y=y;
    }
    public getPosition(){
        return `${this.x},${this.y}`
    }
}
```

#### 2.private 私有修饰符

`private`表示私有的，它修饰的属性在类的定义外面是没法访问的

```tsx
class Parent{
    private name:string;
    constructor(name:string){
        this.name=name;
    }
}
const ming=new Parent("duke");
console.log(ming);//{name:"duke"}
console.log(ming.name);
//error 属性"name"为私有属性，只能在类"Parent"中访问
```

#### 3.protected 受保护修饰符

`protected`修饰符是受保护修饰符，和`private`有些相似，但它可以在继承该类的子类中访问

```tsx
class Parent{
    protected age:number;
    constructor(age:number){
        this.age=age;
    }
    protected getAge(){
        return this.age
    }
}
class Child extends Parent {
  constructor(age: number) {
    super(age);
  }
}
console.log("protected=>", new Child(3).getAge());
//属性"getAge"受保护，只能在类"Parent"及其子类中访问
```

`protected`还能用来修饰 constructor 构造函数，加了`protected`修饰符之后，这个类就不能再用来创建实例，只能被子类继承

```tsx
class Parent{
    protected constructor(){
        //
    }
}
const p = new Parent();
//error 类"Parent"的构造函数是受保护的，仅可在类声明中访问
class Child extends Parent{
    constructor(){
        super()
    }
}
const c = new Child();
```

#### 4.readonly 只读修饰符

在类里可以使用`readonly`关键字将属性设置为只读

```tsx
class UserInfo{
    readonly name:string;
    constructor(name:string){
        this.name=name;
    }
}
const user = new UserInfo("duke");
user.name = "haha";
//error Cannot assign to "name" because it is a read-only property;
```

## 参数属性

参数属性：就是在 constructor 构造函数的参数前面加上访问限定符，也就是 public、private、protected、readonly 中的任意一个。

用来简化过程：在类的定义的顶部初始化实例属性，在 constructor 里接受参数然后对实例属性进行赋值；

```tsx
class A{
    constructor(public name:string){}
}
const a=new A("duke");
console.log(a.name);//"duke"
```

## 静态属性

和 ES6 的类一样，在 TS 中一样使用`static`关键字来指定属性或方法是静态的，实例将不会添加这个静态属性，也不会继承这个静态方法。

```tsx
class B {
  public static age: number = 18;
  private static hobby:string = "coding";
  constructor() {}
}
console.log(new B().age);
//error Property "age" is a static member of type "B";
console.log(B.hobby);
//error 属性"hobby"为私有属性，只能在类"B"中访问
console.log(B.age);//18
```

## 可选属性

用`?`符号来标记属性

```tsx
class F {
  public age?: number;
  constructor(public name: string, age?: number, hobby?: string) {
    this.age = age;
  }
}
console.log("可选类属性1=>", new F("duke"));
//{name:"duke",age:undefined}
console.log("可选类属性2=>", new F("duke", 18, "coding"));
//{name:"duke",age:18}
```

## 存取器

ES6标准中的存值函数和取值函数，就是在设置/访问属性值的时候调用的函数，用法和写法与在 ES6中没有区别

```tsx
class K {
  private _name: string;
  constructor(name: string) {
    this._name = name;
  };
  set name(val: string) {
    console.log("setter:", val);
    this._name = val;
  }
  get name() {
    console.log("getter:", this._name);
    return this._name;
  }
}
const kk = new K("duke");
console.log("存取器=>", kk.name = "haha")
console.log("存取器=>", kk.name)

//setter: haha
//存取器=> haha
//getter: haha
//存取器=> haha
```

## 抽象类

抽象类一般用来被其他类继承，而不直接用它创建实例。使用关键字`abstract`不仅可以标记类和类里面的方法， 还可以标记类中定义的属性和存取器。抽象方法和抽象存取器都不能包含实际的代码块。

```tsx
abstract class People {
  abstract _name: string;
  abstract get name(): string;
  abstract set name(value: string);
  abstract sayHello(): void;
}
class Son extends People {
  _name: string;
  constructor(_name: string) {
    super()
    this._name = _name;
  }
  sayHello() {
    console.log("抽象类=>", "hello")
  }
  get name() {
    console.log("抽象类getter=>", this._name);
    return this._name;
  }
  set name(val: string) {
    console.log("抽象类setter=>", this._name);
    this._name = val;
  }
}
const son = new Son("duke");
console.log("抽象类=>", son.name = "haha");
console.log("抽象类=>", son.name);

//抽象类setter=> duke
//抽象类=> haha
//抽象类getter=> haha
//抽象类=> haha
```

在抽象类里定义的抽象方法 sayHello，在子类中是不会继承的，所以在子类中必须实现该方法的定义。

## 实例类型

当我们定义一个类，并创建实例后，这个实例的类型就是创建他的类：

创建实例的时候指定 god 的类型为 People 并不是必须的，TS 会推断出他的类型，虽然指定了类型，但是当我们再定义一个和 People 类同样实现的类 Animal，并且创建实例赋值给 god 的时候，是没有问题的。

```tsx
class People {
  constructor(public name: string) {}
}
let god: People = new People("duke");

class Animal {
  constructor(public name: string) {}
}
god = new Animal("shao");
console.log("god instanceof People=>", god instanceof People);//false
console.log("god instanceof Animal=>", god instanceof Animal);//true
```

使用`instanceof`关键字实现对创建实例的类的判断。

## 补充

#### 1.类类型接口

使用接口可以强制一个类的定义必须包含某些内容，如果是接口和接口、类和类直接的继承，使用 `extends`，如果是类继承接口，则使用`implements`

```tsx
interface Food{
    type:string;
}
class Apple implements Food{
//Class 'Apple' incorrectly implements interface 'Food'.
//Property 'type' is private in type 'Apple' but not in type 'Food'.
    private type:string;
    constructor(){}
}
```

#### 2.接口继承类

接口可以继承一个类，当接口继承了该类后，会继承类的成员，但是不包括其实现，也就是只继承成员以及成员类型。接口还会继承类的`private`和`protected`修饰的成员，当接口继承的这个类中包含这两个修饰符修饰的成员时，这个接口只可以被这个类或它的子类实现。

```tsx
class People {
  protected age: number = 8;
}
class Animal {
  type: string = "whatever";
}
interface Man extends People {};
interface Dog extends Animal {
  age: number;
};
class Son extends People implements Man {
  age: number;
  constructor(age: number) {
    super();
    this.age = age;
  }
}
class dog implements Dog {
  age: number;
  type = "haha";
  constructor(age: number) {
    this.age = age;
  }
}
console.log(new Son(18))
console.log(new dog(17))
```

#### 3.在泛型中使用类类型

```tsx
const create=<T>(c:{new():T}):T=>{
              return new c();
          }
class Info{
              age:number;
          }
create(Info).age;
create(Info).name;
//error 类型"Info"上不存在属性"name";
```

参数 `c` 的类型定义中，`new()`代表调用类的构造函数，它的类型也就是类创建实例后的实例的类型。

`return new c()`这里使用传进来的类 c 创建一个实例并返回，返回的实例类型也就是函数的返回值类型。

所以通过这个定义，TS 就知道，调用 create 函数，传入的和返回的值都应该是同一个类类型。