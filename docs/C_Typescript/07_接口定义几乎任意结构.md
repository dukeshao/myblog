---
title: 07_接口定义几乎任意结构
date: 2019-10-27 14:53:49
categories: 
- C_Typescript
tags:
---

## 基本用法

使用 interface 来定义接口。

注意在定义接口的时候，不要把他理解为是在定义一个对象，而要理解为{}括号包裹的是一个代码块，里面是一条条声明语句，只不过声明的不是变量的值而是类型。每条声明之前用换行分隔即可，或者也可以使用分号或者逗号。

```tsx
interface Info{
    firstName:string;
    lastName:string;
}
const getFullName=({firstName,lastName}:Info)=>{
    return `${firstName} ${lastName}`;
}
```

## 可选属性

有时不是所有定义在 interface 中的属性都是必须的，typescript 中便为我们提供了可选属性，在属性名后面加个`?`即可

```tsx
interface Vegetables{
    color?:string;
    type:string;
}

/*
这里可能 TSLint 会报一个警告，告诉我们接口应该以大写的`i`开头，在 tslint.json 的 rules 里添加"interface-name":[true,"never-prefix"]来关闭
*/
```

## 多余属性检查

定义的变量比接口少了一些或者多了一些属性是不允许的

```tsx
getVegetables({
  type: "tomato",
  size: "big" // 'size'不在类型'Vegetables'中
});

/*
这里可能 TSLint 会报一个警告，告诉我们属性名没有按开头字母顺序排列属性列表，在 tslint.json 的 rules 里添加" object-literal-sort-keys":[false]来关闭
*/
```

## 绕开多余属性检查

1.使用类型断言

```tsx
interface Vegetables {
  color?: string;
  type: string;
}
const getVegetables = ({ color, type }: Vegetables) => {
  return `A ${color ? color + " " : ""}${type}`;
};
getVegetables({
  type: "tomato",
  size: 12,
  price: 1.2
} as Vegetables);
```

2.添加索引签名

更好的方法是添加索引签名，先来看怎么实现

```tsx
interface Vegetables {
  color: string;
  type: string;
  [prop: string]: any;
}
const getVegetables = ({ color, type }: Vegetables) => {
  return `A ${color ? color + " " : ""}${type}`;
};
getVegetables({
  color: "red",
  type: "tomato",
  size: 12,
  price: 1.2
});
```

3.利用类型兼容性

这种方法现在还不是很好理解，也是不推荐使用的

```tsx
interface Vegetables {
  type: string;
}
const getVegetables = ({ type }: Vegetables) => {
  return `A ${type}`;
};

const option = { type: "tomato", size: 12 };
getVegetables(option);
```

上面这种方法完美通过检查，我们将对象字面量赋给一个变量`option`，然后`getVegetables`传入`option`，这时没有报错。是因为直接将对象字面量传入函数，和先赋给变量再将变量传入函数，这两种检查机制是不一样的，后者是因为类型兼容性。简单地来说：如果 b 要赋值给 a，那要求 b 至少需要与 a 有相同的属性，多了无所谓。

在上面这个例子中，`option`的类型应该是`Vegetables`类型，对象`{ type: ‘tomato’, size: 12 }`要赋值给 `option`，`option`中所有的属性在这个对象字面量中都有，所以这个对象的类型和`option`(也就是`Vegetables`>类型)是兼容的，所以上面例子不会报错。

## 只读属性

使用 const 定义一个对象，然后修改对象里的属性的值是不会报错的；

如果我们要保证对象的属性值不可修改，需要使用 readonly

```tsx
interface Info {
  readonly name: string;
}
const info: Info = {
  name: "Lison"
};
info["name"] = "Haha"; // Cannot assign to 'name' because it is a read-only property
```



## 函数类型

接口可以描述普通对象，还可以描述函数类型；

实际定义函数的时候，名字是无需和接口中参数名相同的，只需要位置对应即可。

```tsx
interface AddFunc {
  (num1: number, num2: number): number;
}

const add: AddFunc = (n1, n2) => n1 + n2;
const join: AddFunc = (n1, n2) => `${n1} ${n2}`; // 不能将类型'string'分配给类型'number'
add("a", 2); // 类型'string'的参数不能赋给类型'number'的参数
```


