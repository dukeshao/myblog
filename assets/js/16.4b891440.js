(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{492:function(t,e,n){"use strict";n.r(e);var a=n(4),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"一、运动原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、运动原理"}},[t._v("#")]),t._v(" 一、运动原理")]),t._v(" "),n("p",[t._v("不断改变对象的属性产生动画的效果")]),t._v(" "),n("h2",{attrs:{id:"二、动画分类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、动画分类"}},[t._v("#")]),t._v(" 二、动画分类")]),t._v(" "),n("h3",{attrs:{id:"匀速运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#匀速运动"}},[t._v("#")]),t._v(" 匀速运动")]),t._v(" "),n("p",[t._v("速度保持不变的运动")]),t._v(" "),n("h4",{attrs:{id:"飞翔的小鸟"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#飞翔的小鸟"}},[t._v("#")]),t._v(" 飞翔的小鸟")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//1.获取元素及初始化速度变量\nlet bird = document.querySelector('img');\nlet speed = 7;\n//2.设置定时器\nlet timer = setInterval(()=>{\n\t//2.1 获取元素当前位置\n\tlet left = bird.offsetLeft;\n    //2.3 边界处理\n    if(left >= window.innerWidth - bird.offsetWidth){\n        left = window.innerWidth - bird.offsetWidth -speed;\n        clearInterval(timer);\n    }\n    //2.2 将当前位置+速度变量值，更新赋值给当前元素的位置样式\n    bird.style.left = left + speed + 'px';\n},20);\t\n")])])]),n("h4",{attrs:{id:"圆周运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#圆周运动"}},[t._v("#")]),t._v(" 圆周运动")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("//1.获取太阳、地球半径\nvar sun_r = 155;\nvar earth_r = 15;\n//2.设置太阳居中,太阳左上角的定位\nsun.style.left = (window.innerWidth-sun.offsetWidth)/2 +'px';\nsun.style.top = (window.innerHeight-sun.offsetHeight)/2 +'px';\n//3.设置地球初始角度\nvar deg = 0;\ngetPos(deg);\n//4.设置定时器，实现角度改变\nsetInterval(function(){\n    deg +=5;\n    getPos(deg);\n},30)\n//设置地球左上角的位置\nfunction getPos(deg){\n    var rad = toRad(deg);\n    var a = sun_r*Math.sin(rad);\n    var b = sun_r*Math.cos(rad);\n    var x = window.innerWidth/2+a-earth_r;\n    var y = window.innerHeight/2-b-earth_r;\n    earth.style.left = x +'px';\n    earth.style.top = y +'px';\n}\n//角度转弧度\nfunction toRad(deg){\n    return deg*Math.PI/180;\n}\n")])])]),n("h3",{attrs:{id:"加速运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#加速运动"}},[t._v("#")]),t._v(" 加速运动")]),t._v(" "),n("p",[t._v("速度不断增加的运动")]),t._v(" "),n("h4",{attrs:{id:"自由落体"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自由落体"}},[t._v("#")]),t._v(" 自由落体")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//其实就是比匀速运动多了速度变量更新而已！！！\n//1.获取元素及初始化速度变量\t\nlet ball = document.querySelector(\".ball\");\nlet speed = 1; \n//2.设置定时器\nlet timer = setInterval(()=>{\n\t//2.1 获取元素当前位置\n    let top  = ball.offsetTop;\n    //2.2 更新速度变量\n    speed++;\n    //2.4 边界处理\n    if(top >= window.innerHeight-ball.offsetHeight){\n        top = window.innerHeight - ball.offsetHeight-speed;\n        clearInterval(timer);\n    }\n    //2.3 将当前位置+速度变量值，更新赋值给当前元素的位置样式\n\tball.style.top = top + speed + 'px';\n}, 20)\n")])])]),n("h3",{attrs:{id:"减速运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#减速运动"}},[t._v("#")]),t._v(" 减速运动")]),t._v(" "),n("p",[t._v("速度不断减小的运动")]),t._v(" "),n("h4",{attrs:{id:"刹车运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#刹车运动"}},[t._v("#")]),t._v(" 刹车运动")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//减速运动边界处理时，更多判断的是速度！！！\n//1.获取元素及初始化速度变量\nvar car = document.querySelector('.car');\nvar speed = 60;\n//2. 设置定时器\nvar timer = setInterval(()=>{\n\t//2.1 获取元素当前位置\n    var left = car.offsetLeft;\n    //2.2 更新速度变量\n    speed -= 3;\n   //2.3 速度边界处理\n    if(speed<=0){\n        speed = 0;\n        clearInterval(timer);\n    }\n\t//2.4 将位置更新赋值给当前元素的样式\n\tcar.style.left = left + speed + 'px';\n},50);\n")])])]),n("h3",{attrs:{id:"抛物线运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抛物线运动"}},[t._v("#")]),t._v(" 抛物线运动")]),t._v(" "),n("p",[t._v("水平方向速度不断减小，垂直方向速度不断增加")]),t._v(" "),n("h4",{attrs:{id:"抛球不反弹"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抛球不反弹"}},[t._v("#")]),t._v(" 抛球不反弹")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//垂直方向加速与水平方向减速的结合\n//1.获取元素及初始化速度变量\nvar basketball = document.querySelector('.basketball');\nvar xspeed = 20;\nvar yspeed = 0;\n//2. 设置定时器\nvar timer = setInterval(()=>{\n\t//2.1 获取元素当前位置\n    var left = basketball.offsetLeft;\n    var top = basketball.offsetTop;\n\t//2.2 更新速度变量\n    yspeed++;\n\txspeed -= 0.01;\n\t//2.3 边界判断\n    if(top >= window.innerHeight - basketball.offsetHeight){\n    \ttop = window.innerHeight - basketball.offsetHeight - yspeed;\n        clearInterval(timer);\n    }\n\tif(xspeed <= 0){\n    \txspeed = 0;\n    }\n\t//2.4 将位置更新赋值给当前元素的样式\n    basketball.style.left = left + xspeed + 'px';\n    basketball.style.top = top + yspeed + 'px';\n},30);\n")])])]),n("h4",{attrs:{id:"抛物线的重力回弹"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抛物线的重力回弹"}},[t._v("#")]),t._v(" 抛物线的重力回弹")]),t._v(" "),n("h3",{attrs:{id:"缓冲运动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#缓冲运动"}},[t._v("#")]),t._v(" 缓冲运动")]),t._v(" "),n("p",[t._v("一开始速度很快，然后慢下来，直到停止")]),t._v(" "),n("p",[t._v("缓冲运动的关键：动态计算速度（一般都跟目标值-当前值相关）")]),t._v(" "),n("h4",{attrs:{id:"点击返回顶部"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#点击返回顶部"}},[t._v("#")]),t._v(" 点击返回顶部")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//1.window.onscroll事件，实现当window.scrollY的值大于一定的值时，出现点击返回顶部按钮\nwindow.onscroll = ()=>{}\n//2.给按钮绑定点击事件（事件触发定时器，一般都要先清除上一次的定时器）\ntotop.onclick = ()=>{\n\tclearInterval(timer);\n    //2.2 开启定时器\n    var timer = setInterval(()=>{\n    \t//2.2.1 获取元素当前位置\n\t\tvar scrollTop = window.scrollY;\n        //2.2.2 根据当前位置，更新速度变量值\n        var speed = parseInt(scrollTop/10);\n        // 2.2.3 边界判断\n        if(speed<=10){\n            speed = 10;\n            clearInterval(timer);\n        }\n        //2.2.4 滚动到位置更新的位置\n\t\twindow.scrollBy(0,-speed);\n\t},30);\n}\n")])])]),n("h4",{attrs:{id:"图片展示上移效果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图片展示上移效果"}},[t._v("#")]),t._v(" 图片展示上移效果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("for(let i=0;i<cols.length;i++){\n\tcols[i].onmouseenter = function(){\n        clearInterval(this.timer);\n        // 1.获取当前a标签及设置目标值\n        let link = this.children[1];\n        let target = 0;\n        //2.鼠标移入（不想冒泡就用enter）,设置定时器拿到当前top及设置缓冲速度。\n        this.timer = setInterval(()=>{\n            let current = link.offsetTop;\n            let speed = Math.ceil((current-target)/10);\n            current -= speed;\n            if(current <= target){\n                clearInterval(this.timer);\n                current = target;\n            }\n            link.style.top = current + 'px';\n        },30);\n    }\n}\n//鼠标移出，回复原来的位置。\n")])])]),n("h3",{attrs:{id:"透明度变换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#透明度变换"}},[t._v("#")]),t._v(" 透明度变换")]),t._v(" "),n("h4",{attrs:{id:"图片的淡入淡出"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图片的淡入淡出"}},[t._v("#")]),t._v(" 图片的淡入淡出")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("box.onmouseover = function(){\n\t//4.多次进入事件，清楚上一次的定时器\n    clearInterval(timer);\n    timer = setInterval(function(){\n    \t//1.鼠标移入，设置定时器，获取当前透明度*100.\n        var cur = getComputedStyle(img).opacity*100;\n        //2.具体的change看你想做什么运动。缓冲运动\n        var change = Math.ceil((100-cur)/10);\n        cur += change;\n\t\t//3.当获取到的当前透明度+change值>=100时，设置当前透明度的值。清除定时器\n        if(cur >= 100){\n            cur = 100;\n            clearInterval(timer);\n        }\n        //3.透明度改变的值除于100，给元素赋值样式\n        img.style.opacity = cur/100;\n    },100)\n}\n//鼠标移出，回复半透明效果。\n")])])]),n("h2",{attrs:{id:"三、动画的封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、动画的封装"}},[t._v("#")]),t._v(" 三、动画的封装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('// 缓冲运动原理，利用(target-current)/10得到速度\nfunction animate(ele,attr,target){\n    clearInterval(ele.timer);\n    if(attr == "opacity"){target *= 100;}\n    //1.定时器:\n    //(1)获取ele的attr属性值，可能存在px、deg、target获取单位及数值\n    //(2)设置缓冲速度\n    //(3)设置当前属性值，判断达到目标值，清除定时器\n    //(4)设置给元素作为样式\n    //2.考虑透明度\n    //3.函数一进来，先清除定时器，避免事件触发重复添加\n    ele.timer = setInterval(function(){\n        var current = getComputedStyle(ele)[attr];\n        var unit = current.match(/[a-z]+$/i);\n        unit = unit ? unit[0]: "";\n        current = parseFloat(current);\n        if(attr == "opacity"){current *= 100;}\n        var speed = (target-current)/10;\n        speed = speed>0? Math.ceil(speed) : Math.floor(speed);\n        current += speed;\n        if(current == target){\n           clearInterval(ele.timer);\n        }\n        if(attr == "opacity"){current /= 100;}\n     \tele.style[attr] = current + unit;\n\t},100)\n}\n')])])]),n("p",[t._v("利用封装的代码，书写轮播图")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//（一） 定时切换图片\n//1.初始化索引\nvar index  = 0；\nlet timer = setInterval(function(){\n\t//2.设置定时器让索引递增，改变图片的top值为，为-图片大小*索引\n    index++;\n    //3.当索引大于等于图片数量时，将索引重置为0\n    if(index >= ul.children.length){\n        index = 0;\n    }\n    ul.style.top = -320 * index +'px';\n}, 1000)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('//（二） 利用封装animate实现动画\n//1.初始化索引\nvar index  = 0；\nlet timer = setInterval(autoPlay, 1000)\nlbt.onmouseenter = ()=>{\n\tclearInterval(timer);\n}\nlbt.onmouseleave = ()=>{\n\ttimer = setInterval(autoPlay,1000);\n}\nfunction autoPlay(){\n    //2.设置定时器让索引递增，将-图片大小*索引作为每次动画的目标值\n    index++;\n    //3.当索引大于等于图片数量时，将索引重置为0\n    if(index >= ul.children.length){\n        index = 0;\n    }\n    var target = -320 * index;\n    animate(ul,"top",target);\n}\n')])])]),n("h2",{attrs:{id:"完善animate封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完善animate封装"}},[t._v("#")]),t._v(" 完善animate封装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function animate(ele,opt,callback){\n\t// 2.记录动画的数量，遍历时加1。执行后减1。动画结束后执行回调函数\n\tlet timerLen = 0;\n    // 1.遍历opt，获取所有attr和target\n    for(var attr in opt){\n        timerLen++;\n        createTimer(attr);\n    }\n    function createTimer(attr){\n        let target = opt[attr];\n        // 3.1设置定时器的名字与attr关联\n        let timerName = attr + 'timer';\n        // 3.2清除定时器，避免多个定时器用作于一个效果\n\t\tclearInterval(ele[timerName]);\n\t\tele[timerName] = setInterval(()=>{\n            let current = getCss(ele,attr);//100px,45deg,0.5(string)\n            let unit = current.match(/[a-z]+$/i);//[0:px,index:6,input:current],null\n            unit = unit ? unit[0] : '';\n            current = parseFloat(current);\n            let speed = (target-current)/10;\n\t\t   speed = speed>0 ? Math.ceil(speed) : Math.floor(speed);//1,-1\n\t\t   current += speed;\n\t\t   if(current === target ){\n\t\t\t\tclearInterval(ele[timerName]);\n\t\t\t\t// 每一个动画完成数量减一\n\t\t\t\ttimerLen--;\n\t\t\t\t// 动画结束后执行回掉函数\n                if(timerLen === 0){\n                    typeof callback==='function' && callback();\n                }\n             }\n             ele.style[attr] = current + unit;\n\t\t},30);\n\t}\n}\t\t\t\n")])])]),n("h3",{attrs:{id:"水平无缝滚动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#水平无缝滚动"}},[t._v("#")]),t._v(" 水平无缝滚动")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("2）无缝滚动\n    * 把第一张复制到最后\nul.appendChild(ul.children[0].cloneNode(true));\n1）获取ul子元素的长度设置ul宽度，达到水平排列的效果\nlet len = ul.children.length;\nlet imgWidth;\nul.querySelector('img').onload = function(){\n\timgWidth = this.offsetWidth;\n\tul.style.width = imgWidth*len + 'px';\n}\n3）水平轮播效果\nlet timer = setInterval(autoPlay,3000);\nfunction autoPlay(){\n    index++;\n    show();\n}\nfunction show(){\n\t//当show()执行到最后一张图片len-1时，代表索引为0的图片。\n\t//再次进入autofocus，index++后，其实要执行的下一次索引应该为1。所以要把当前位置改成0.\n    if(index >= len){//0,1,2,3,4\n        ul.style.left = 0;\n        index = 1;\n    }\n    animate(ul,{left:-imgWidth*index});\n    // 遍历所有页码，取消高亮，给点点被点击的页码添加高亮\n    for(let i=0;i<len-1;i++){//0,1,2,3\n        page.children[i].className = '';\n    }\n    if(index === len - 1){\n        page.children[0].className = 'active';\n    }else{\n        page.children[index].className = 'active'\n    }\n}\n4）移入移出，清除轮播效果\nfocus.onmouseenter = ()=>{clearInterval(timer);}\nfocus.onmouseleave = ()=>{timer = setInterval(autoPlay,3000);}\n5）添加分页效果，点击分页切换\nlet page = setPage();\nfunction setPage(){\n    let page = document.createElement('div');\n    page.className = 'page';\n    for(let i=1;i<len;i++){\n        let span = document.createElement('span');\n        span.innerText = i;\n        if(i===1){\n            span.classList.add('active');\n        }\n        page.appendChild(span);\n    }\n    focus.appendChild(page);\n    return page;\n}\nfocus.onclick = e=>{\n    if(e.target.parentNode.className === 'page'){\n        index = e.target.innerText-1;\n        show();\n    }\n}\n6）添加前后按钮，实现上一张、下一张的效果（待完成...）\n")])])]),n("p",[t._v("瀑布流")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("(1)获取图片宽,计算当前容器能容纳多少列\n//\t* 列数 = parseInt(容器宽度/图片宽度)\nlet imgWidth = items[0].offsetWidth;\nlet col = Math.floor((window.innerWidth-17)/imgWidth);//10.6\n//2）计算水平间隔\n//    * 间隔 = （容器宽度-17）%图片宽度/(列数+1)，17为滚动条宽度\nlet gap = ((window.innerWidth-17)%imgWidth)/(col+1);\n// 3）创建一个数组pos\n//\t  * 用来保存第一行每列图片左上角坐标(left,top)\nlet pos = [];\nfor(let i=0;i<col;i++){\n    pos.push({\n        left:(i+1)*gap + i*imgWidth,\n        top:gap\n    })\n}\n// 4）遍历所有图片，往容器里添加图片\n    //  当前图片加载时，遍历数组pos，查找最小top值及对应的索引，给当前元素设置样式\n    //  然后更新当前索引，即minIdx的top值,top = 容器高度（由图片高度跟上一次gap撑开） + gap \nfor(let i=0;i<items.length;i++){\n    let currentImg = items[i].querySelector('img');\n    // 等图片加载完成获取div高度\n    currentImg.onload = function(){\n        let minIdx = 0;\n        let minTop = pos[minIdx].top;\n        for(let j=1;j<pos.length;j++){\n            if(pos[j].top < minTop){\n                minTop = pos[j].top;\n                // 更新最小索引值\n                minIdx = j;\n            }\n        }\n        animate(items[i],{left:parseInt(pos[minIdx].left),top:parseInt(pos[minIdx].top)})\n        // 然后更新当前top值\n        pos[minIdx].top += gap + items[i].offsetHeight;\n    }\n}\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);