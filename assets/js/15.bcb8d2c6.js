(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{495:function(t,a,s){"use strict";s.r(a);var e=s(4),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"一、面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、面向对象"}},[t._v("#")]),t._v(" 一、面向对象")]),t._v(" "),s("h2",{attrs:{id:"概念oop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念oop"}},[t._v("#")]),t._v(" 概念oop")]),t._v(" "),s("p",[t._v("利用对象进行编程的一种思想。object-oriented programming，简称oop")]),t._v(" "),s("h2",{attrs:{id:"创建对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建对象"}},[t._v("#")]),t._v(" 创建对象")]),t._v(" "),s("p",[t._v("1.字面量")]),t._v(" "),s("blockquote",[s("p",[t._v("var obj={}")])]),t._v(" "),s("p",[t._v("2.通过new关键字实例化对象")]),t._v(" "),s("blockquote",[s("p",[t._v("var obj=new Object();")])]),t._v(" "),s("p",[t._v("3.Object.create()")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\n")])])]),s("p",[t._v("(1)工厂模式")]),t._v(" "),s("p",[t._v("在ECMAScript中是无法创建类的，开发人员就发明了一种函数，用函数来封装特定接口创建对象的细节。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createPerson")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" job")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("job "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" job"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("sayName")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" person1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createPerson")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'zxj'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("23")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Software Engineer"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("缺点：没有解决对象识别的问题(得到的都是o对象，对象的类型都是Object)")]),t._v(" "),s("p",[t._v("(2)自定义构造函数（类的概念）")]),t._v(" "),s("p",[t._v("ECMAScript中的构造函数可以用来创建特定类型的对象。像Object和Array的原生的构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" age")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("sayName")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" s1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"王铁锤"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//可以通过控制台查看一下person1与s1的区别，更好理解。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//person1: \t__proto__ 直接指向对象 Object 的原型")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//\ts1: \t__proto__ 指向 Student 的原型 -> Student 的原型才指向对象 Object 的原型")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如此可以识别对象")]),t._v("\n")])])]),s("h2",{attrs:{id:"构造函数与普通函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数与普通函数的区别"}},[t._v("#")]),t._v(" 构造函数与普通函数的区别")]),t._v(" "),s("blockquote",[s("p",[t._v("唯一区别：调用方式不同")])]),t._v(" "),s("ul",[s("li",[t._v("任何函数，只要通过new操作符来调用，它就可以作为构造函数；")]),t._v(" "),s("li",[t._v("而任何构造函数，如果不通过new 操作符来调用，那它跟普通函数无区别。")])]),t._v(" "),s("blockquote",[s("p",[t._v("约定：构造函数名首字母大写")])]),t._v(" "),s("h2",{attrs:{id:"new-调用自定义构造函数-相当于执行了哪些步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-调用自定义构造函数-相当于执行了哪些步骤"}},[t._v("#")]),t._v(" new 调用自定义构造函数,相当于执行了哪些步骤")]),t._v(" "),s("ul",[s("li",[t._v("创建一个新对象(在内部隐式调用了new Object())")]),t._v(" "),s("li",[t._v("将构造函数的作用域赋给新对象(把this绑定到实例对象)")]),t._v(" "),s("li",[t._v("执行构造函数中的代码(为这个新对象添加属性)")]),t._v(" "),s("li",[t._v("返回新对象")])]),t._v(" "),s("h2",{attrs:{id:"this-的三种指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-的三种指向"}},[t._v("#")]),t._v(" this 的三种指向")]),t._v(" "),s("ul",[s("li",[t._v("函数名()： this指的是调用函数的当前对象")]),t._v(" "),s("li",[t._v("ele.事件=函数名 ：this指的是ele")]),t._v(" "),s("li",[t._v("new 函数名()： this为实例对象(new出来的对象)")])]),t._v(" "),s("h1",{attrs:{id:"二、对象的三大重要概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、对象的三大重要概念"}},[t._v("#")]),t._v(" 二、对象的三大重要概念")]),t._v(" "),s("p",[t._v("(一)构造函数")]),t._v(" "),s("ul",[s("li",[t._v("每个函数都有一个prototype指向原型对象")])]),t._v(" "),s("p",[t._v("(二)实例对象")]),t._v(" "),s("ul",[s("li",[t._v("new 出来的对象就是实例对象,实例会复制构造函数内所有的属性和方法")]),t._v(" "),s("li",[t._v("可以实例对象获取原型对象")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("实例对象__proto__\n")])])]),s("p",[t._v("(三)原型对象")]),t._v(" "),s("ul",[s("li",[t._v("每个函数都有一个prototype指向原型对象")]),t._v(" "),s("li",[t._v("原型对象默认包含一个constructor属性,指向构造函数")]),t._v(" "),s("li",[t._v("任何写在原型对象中的属性和方法,都可以让所有实例对象共享")])]),t._v(" "),s("h2",{attrs:{id:"判断原型和实例的关系（返回布尔值）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断原型和实例的关系（返回布尔值）"}},[t._v("#")]),t._v(" 判断原型和实例的关系（返回布尔值）")]),t._v(" "),s("p",[t._v("constructor: 得到构造函数的引用，一般用于判断该实例是否由某一构造函数生成")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("实例.constructor == Student //true\n")])])]),s("p",[t._v("instanceof: 检测某个对象是不是某一构造函数的实例，适用于原型链中的所有实例")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("实例 instanceof Student //true\n实例 instanceof Object //true\n")])])]),s("p",[t._v("isPrototypeOf: 判断当前对象是否为实例的原型对象")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("原型对象.isPrototypeOf(实例) //true\n")])])]),s("h1",{attrs:{id:"三、解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、解决方案"}},[t._v("#")]),t._v(" 三、解决方案")]),t._v(" "),s("p",[t._v("构造函数+原型对象")]),t._v(" "),s("ul",[s("li",[t._v("使用构造函数添加私有属性")]),t._v(" "),s("li",[t._v("使用原型对象添加共享方法")])]),t._v(" "),s("p",[t._v("优点")]),t._v(" "),s("ul",[s("li",[t._v("实例对象都有自己的独有属性")]),t._v(" "),s("li",[t._v("实例共享了原型中的方法,最大限度的节省了内存")]),t._v(" "),s("li",[t._v("支持向构造函数传递参数")])]),t._v(" "),s("h1",{attrs:{id:"四、对象的属性特性-es5对象扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、对象的属性特性-es5对象扩展"}},[t._v("#")]),t._v(" 四、对象的属性特性(ES5对象扩展)")]),t._v(" "),s("h2",{attrs:{id:"值属性的属性特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#值属性的属性特性"}},[t._v("#")]),t._v(" 值属性的属性特性")]),t._v(" "),s("ul",[s("li",[t._v("configurable")])]),t._v(" "),s("blockquote",[s("p",[t._v("可配置性，控制着其描述的属性的修改，表示能否修改属性特性")])]),t._v(" "),s("ul",[s("li",[t._v("enumerable")])]),t._v(" "),s("blockquote",[s("p",[t._v("可枚举性,表示能否通过for..in遍历得到属性")])]),t._v(" "),s("ul",[s("li",[t._v("writable")])]),t._v(" "),s("blockquote",[s("p",[t._v("可写性, 表示能够修改属性的值")])]),t._v(" "),s("ul",[s("li",[t._v("value")])]),t._v(" "),s("blockquote",[s("p",[t._v("数据属性,表示属性的值,默认值为undefined")])]),t._v(" "),s("p",[t._v("obj.**创建属性, 默认值属性为true")]),t._v(" "),s("p",[t._v("Object.defineProperty(obj,proper)创建属性,默认值属性为false")]),t._v(" "),s("h2",{attrs:{id:"与属性特性相关的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与属性特性相关的方法"}},[t._v("#")]),t._v(" 与属性特性相关的方法")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("设置属性特性：\nObject.defineProperty(obj, property, descriptor) 给对象的某个属性设置属性特性\nObject.defineProperties(object, descriptors) 给对象的所有属性设置属性特性\n\n获取属性特性：\nObject.getOwnPropertyDescriptor(object, propertyname)\n\n获取对象的所有属性：\nObject.keys(object) 只获取到可枚举的属性\nObject.getOwnPropertyNames(object) 获取所有属性的名称（包含不能枚举的属性）\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('var obj = {\n    a:1,\n    b:"lemon"\n}\n//1.给对象添加一个属性，同时设置属性特性。此时其他的属性特性不设置默认都为false。\n//即configurable为false，不可以修改属性特性。\n//即enumerable为false，不可以枚举\n//即writable为false，不可写，不可以修改属性值\nObject.defineProperty(obj,"c",{value:"laoxie"})； //以上属性特性均可改成true，实现相应的功能。\n\n// 2.同时修改多个属性特性\nObject.defineProperties(obj, {\n    b:{value:\'css4\',enumerable:false},\n    c:{writable:true}  //报错，因为上面定义该属性的configurable为false，意思是不可以修改属性特性\n})\n\n//建议：用传统方式添加属性，利用defineProperty修改属性特性（configurable为true的前提下）\n')])])]),s("h2",{attrs:{id:"对象属性的遍历与判断"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象属性的遍历与判断"}},[t._v("#")]),t._v(" 对象属性的遍历与判断")]),t._v(" "),s("ul",[s("li",[t._v("for…in")])]),t._v(" "),s("p",[t._v("遍历对象中的所有可枚举属性, 无论该属性存在于实例中还是原型中")]),t._v(" "),s("ul",[s("li",[t._v("in")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("if(name in s1){\n\t//只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中\n}\n")])])]),s("ul",[s("li",[t._v("对象.hasOwnProperty(属性)\n"),s("ul",[s("li",[t._v("检测一个属性是存在于对象本身中")]),t._v(" "),s("li",[t._v("返回true，说明属性存在对象中")]),t._v(" "),s("li",[t._v("返回false，说明属性不存在或在原型中")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("检测一个属性是否存在于原型中：!obj.hasOwnProperty(name) && (name in obj)")])]),t._v(" "),s("h1",{attrs:{id:"五、原型对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、原型对象"}},[t._v("#")]),t._v(" 五、原型对象")]),t._v(" "),s("h2",{attrs:{id:"重置原型对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重置原型对象"}},[t._v("#")]),t._v(" 重置原型对象")]),t._v(" "),s("p",[t._v("重置原型对象，可以一次性给原型对象添加多个方法，但切断了与原来原型对象的联系")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function Popover(){}\nPopover.prototype = {\n    show:function(){},\n    hide:function(){}\n}\n//- 注意覆盖问题（系统的原型对象不建议重写）\n//- 注意识别问题（不可枚举性）\nObject.defineProperty(Popover.prototype,"constructor",{value:"Popover",configurable:true})；\n')])])]),s("h2",{attrs:{id:"内置的原型对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内置的原型对象"}},[t._v("#")]),t._v(" 内置的原型对象")]),t._v(" "),s("p",[t._v("使用内置原型可以给已有构造函数添加方法")]),t._v(" "),s("ul",[s("li",[t._v("数组/字符串/数字等方法调用原理")]),t._v(" "),s("li",[t._v("扩展内置方法")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("if(!Array.prototype.norepeat){\n    Array.prototype.norepeat = function(){\n        return Array.from(new Set(this)); // this：指向实例arr\n\t}\n}\n")])])]),s("h1",{attrs:{id:"六、原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、原型链"}},[t._v("#")]),t._v(" 六、原型链")]),t._v(" "),s("p",[t._v("实例与Object原型对象之间的链条称为原型链")]),t._v(" "),s("ul",[s("li",[t._v("原型模式的访问机制（原型搜索机制)")])]),t._v(" "),s("blockquote",[s("p",[t._v("读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值；")])]),t._v(" "),s("blockquote",[s("p",[t._v("如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值")])]),t._v(" "),s("blockquote",[s("p",[t._v("如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）；")])]),t._v(" "),s("blockquote",[s("p",[t._v("如果在Object的原型对象中还搜索不到，则抛出错误；")])]),t._v(" "),s("h1",{attrs:{id:"七、继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、继承"}},[t._v("#")]),t._v(" 七、继承")]),t._v(" "),s("p",[t._v("继承是面向对象中一个非常重要的特征。指的是：子类继承父类的属性和方法。")]),t._v(" "),s("blockquote",[s("p",[t._v("我们可以通过继承的方式, 在父类的属性和方法基础上, 让子类也拥有这些属性和方法, 并可以扩展。")])]),t._v(" "),s("h2",{attrs:{id:"继承的好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承的好处"}},[t._v("#")]),t._v(" 继承的好处:")]),t._v(" "),s("ol",[s("li",[t._v("子类拥有父类所有的属性和方法（代码复用）；")]),t._v(" "),s("li",[t._v("子类可以扩展自己的属性和方法（更灵活）；")]),t._v(" "),s("li",[t._v("子类可以重写父类的方法")])]),t._v(" "),s("h2",{attrs:{id:"原型链继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承"}},[t._v("#")]),t._v(" 原型链继承")]),t._v(" "),s("ul",[s("li",[t._v("核心：拿父类实例来充当子类原型对象")]),t._v(" "),s("li",[t._v("缺点：\n"),s("ul",[s("li",[t._v("无法操作父类构造函数的属性")])])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function Person(name,age,gender){\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\nPerson.prototype = {\n    say(){console.log(`大家好，我叫${this.name}，欢迎跟大家交朋友`)}  \n}\nObject.defineProperty(Person.prototype,'constructor',{\n    configurable:true,\n    value:Person\n});\nlet lemon = new Person('lemon',32,'女');\n//===============原型链继承==========\nfunction Man(name,age){\n}\nMan.prototype = new Person();\nlet laoxie = new Man('laoxie',18);\n")])])]),s("h2",{attrs:{id:"借用构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#借用构造函数"}},[t._v("#")]),t._v(" 借用构造函数")]),t._v(" "),s("p",[t._v("核心：借父类的构造函数来增强子类实例，相当于把父类的实例属性复制一份给子类实例")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("call：")]),t._v(" "),s("ul",[s("li",[t._v("格式：父类构造函数.call(子类实例,参数1,参数2,参数3...)")])])]),t._v(" "),s("li",[s("p",[t._v("apply：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("格式：父类构造函数.apply(子类实例,[参数1,参数2,参数3...])\ncall与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//aplly用法：借用方法\nvar arr = [20,2,40,33,21,8,22,46,32]\nMath.max.apply(null,arr)\n")])])])])])])]),t._v(" "),s("h2",{attrs:{id:"组合继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[t._v("#")]),t._v(" 组合继承")]),t._v(" "),s("p",[t._v("由于以上继承方法的缺点，实际开发中不可能单纯的只使用一种继承方法，而是利用它们的优点，规避它们的缺点，所以就有了组合继承法")]),t._v(" "),s("ul",[s("li",[t._v("继承属性：借用构造函数\n"),s("ul",[s("li",[t._v("只在构造函数中定义属性")])])]),t._v(" "),s("li",[t._v("继承方法：原型链继承\n"),s("ul",[s("li",[t._v("把所有的方法写入原型对象")])])])]),t._v(" "),s("p",[s("strong",[t._v("组合继承是最常用的继承模式。")])]),t._v(" "),s("ul",[s("li",[t._v("缺点（原型链继承法的缺点）：\n"),s("ul",[s("li",[t._v("在原型对象中生成多余的属性")]),t._v(" "),s("li",[t._v("多次执行父类构造函数")])])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//原型链继承基础上补充借用构造函数\nfunction Man(name,age){\n    Person.call(this,name,age,'男');\n}\n")])])]),s("h2",{attrs:{id:"原型式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型式继承"}},[t._v("#")]),t._v(" 原型式继承")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("核心：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例")])]),t._v(" "),s("li",[s("p",[t._v("解决原型链继承法的缺点：生成多余的属性")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nMan.prototype = object(Person.prototype);\n")])])])])]),t._v(" "),s("p",[t._v("ES5版本的原型式继承：Object.create()")]),t._v(" "),s("h2",{attrs:{id:"寄生组合继承法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合继承法"}},[t._v("#")]),t._v(" 寄生组合继承法")]),t._v(" "),s("p",[t._v("完美的继承方法")]),t._v(" "),s("ul",[s("li",[t._v("核心：\n"),s("ul",[s("li",[t._v("继承属性：借用构造函数")]),t._v(" "),s("li",[t._v("继承方法：原型式继承")])])])]),t._v(" "),s("h2",{attrs:{id:"es6继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6继承"}},[t._v("#")]),t._v(" ES6继承")]),t._v(" "),s("ul",[s("li",[t._v("class定义类\n"),s("ul",[s("li",[t._v("写在类里面的方法实际是给Person.prototype添加方法")]),t._v(" "),s("li",[t._v("constructor方法是类的默认方法，相当于在构造函数内生成属性")])])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//定义类\nclass Person {\n    constructor(name,age) {\n        this.name = name;\n        this.age = age;\n    }\n    getInfo() {\n         return `我叫${this.name},今年${this.age}岁`;;\n    }\n}\n")])])]),s("ul",[s("li",[t._v("extends实现继承\n"),s("ul",[s("li",[t._v("子类继承了父类，在子类构造函数中必须调用super方法。")]),t._v(" "),s("li",[t._v("子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。")])])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// class 子类 extends 父类{}\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Man extends Person {\n    constructor(name, age, gender) {\n        //this.gender = gender; // 报错\n        super(name, age);\n        this.gender = gender; // 正确\n    }\n}   \n")])])]),s("p",[t._v("3.注意")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("子类继承了父类,在子类constructor中必须调用super方法")])]),t._v(" "),s("li",[s("p",[t._v("没有调用super之前,不能使用this关键字")])])]),t._v(" "),s("p",[t._v("4.static 静态方法")]),t._v(" "),s("p",[t._v("如果在一个方法前，加上static关键字，这就称为“静态方法”")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("静态方法不会被实例继承，而是直接通过类来调用"),s("code",[t._v("Person.getInfo()")])])]),t._v(" "),s("li",[s("p",[t._v("父类的静态方法，可以被子类继承"),s("code",[t._v("Man.getInfo()")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Person{\n    constructor(name,age,gender){\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n    // 此处的方法写入原型对象中\n    say(){console.log(大家好,我叫${this.name})}；\n    static eat(){console.log('我是吃货');}\n}\nlet lemon = new Person('lemon',32,'女');\n// 继承方法\nclass Man extends Person{\n    constructor(name,age){\n        // 继承属性\n        super(name,age,'男');\n        this.hobby = ['吃','喝'];\n    }\n}\nlet laoxie = new Man('laoxie',18);\n")])])])])]),t._v(" "),s("h1",{attrs:{id:"九、bind、call、apply"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#九、bind、call、apply"}},[t._v("#")]),t._v(" 九、bind、call、apply")]),t._v(" "),s("p",[t._v("1.bind(对象)")]),t._v(" "),s("p",[t._v("改变函数的this指向,同时返回一个新函数")]),t._v(" "),s("p",[t._v("2.call(对象,参数1,参数2)")]),t._v(" "),s("p",[t._v("改变函数的this指向,并且执行该函数")]),t._v(" "),s("p",[t._v("3.apply(对象,[参数1,参数2])")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("改变函数的this指向,并且执行该函数")])]),t._v(" "),s("li",[s("p",[t._v("apply(null,arr)表示不改变this的指向")])]),t._v(" "),s("li",[s("p",[t._v("允许通过数组将实参传递给形参")])])]),t._v(" "),s("p",[t._v("应用：")]),t._v(" "),s("blockquote",[s("p",[t._v("求数组中最大数和最小数")]),t._v(" "),s("p",[t._v("​\tMath.max()")]),t._v(" "),s("p",[t._v("​\tMath.min()")])]),t._v(" "),s("blockquote",[s("p",[t._v("类数组使用Map 使用本不是自己的方法")])]),t._v(" "),s("blockquote",[s("p",[t._v("判断数据类型, (自己有这个方法,但是想使用别人的这个方法)")])]),t._v(" "),s("p",[t._v("Object.prototype.toString 判断引用数据类型的具体类型")]),t._v(" "),s("h1",{attrs:{id:"十、闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十、闭包"}},[t._v("#")]),t._v(" 十、闭包")]),t._v(" "),s("p",[t._v("1.闭包：定义在一个函数内部的函数")]),t._v(" "),s("p",[t._v("闭包是这样一种机制: 函数嵌套函数, 内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回.")]),t._v(" "),s("p",[t._v("这里涉及到几个概念:")]),t._v(" "),s("ol",[s("li",[t._v("函数嵌套函数")]),t._v(" "),s("li",[t._v("作用域(全局变量和局部变量)\n变量的访问规则")]),t._v(" "),s("li",[t._v("垃圾回收机制(garbage collection)\njs内部不断扫描内存,并清理无引用对象(自动完成);")])]),t._v(" "),s("p",[t._v("2.好处")]),t._v(" "),s("ol",[s("li",[t._v("可以让一个变量长期驻扎在内存当中不被释放")]),t._v(" "),s("li",[t._v("避免全局变量的污染, 和全局变量不同, 闭包中的变量无法被外部使用")]),t._v(" "),s("li",[t._v("私有成员的存在, 无法被外部调用, 只可以自己内部使用")])]),t._v(" "),s("blockquote",[s("p",[t._v("结论：")])]),t._v(" "),s("ul",[s("li",[t._v("闭包是指有权访问另一函数作用域中的变量的函数")]),t._v(" "),s("li",[t._v("闭包，可以访问函数内部的局部变量，并让其长期驻留内存")]),t._v(" "),s("li",[t._v("由于闭包会携带包含它的作用域(运行环境)，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。")])]),t._v(" "),s("p",[t._v("3.缺点：由于闭包会携带包含它的作用域(运行环境),因此会比其他函数占用更多内存,过度使用闭包可能造成性能问题")])])}),[],!1,null,null,null);a.default=n.exports}}]);