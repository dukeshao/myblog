(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{493:function(t,e,a){"use strict";a.r(e);var s=a(4),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、概念"}},[t._v("#")]),t._v(" 一、概念")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.AJAX\n\tAsynchronous Javascript And Xml，Ajax 技术的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现\n\n2.起源\n\t最早出现在2005年的google搜索建议\n3.优点\n\t* 增加速度：减轻服务器的负担,按需加载数据,最大程度的减少冗余请求\n\t* 改善的用户体验：局部刷新页面,减少用户等待时间,带来更好的用户体验\n\t* 页面和数据分离：前后端分离，操作更灵活，后期维护更方便\n4.后端语言和服务器配置\n\t* php + Apache + mySQL\n\t* NodeJS + MongoDB\n\t* Java + tomcat + Oracle\n\t* .NET + IIS + SQL Server\n")])])]),a("h2",{attrs:{id:"二、json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、json"}},[t._v("#")]),t._v(" 二、json")]),t._v(" "),a("h3",{attrs:{id:"_1-json数据-json字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-json数据-json字符串"}},[t._v("#")]),t._v(" 1.json数据(json字符串)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('{"id" : 21465461461461, "name": "张三"},[{"id" : 21465461461461, "name": "张三"}]\n')])])]),a("h3",{attrs:{id:"_2-json字符串与对象的转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-json字符串与对象的转换"}},[t._v("#")]),t._v(" 2.json字符串与对象的转换")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('1.json字符串转成对象的转换\n(1)eval("("+json字符串+")"); \n\t它的作用是，将一个普通的json格式(不标准的json字符串)的字符串，转换成Json格式的对象\n\tvar list = eval("("+request.responseText+")");\n(2)JSON.parse(); //把JSON字符串转成JSON对象(js对象/数组)【es5】\n2.把JSON对象转成JSON字符串\n\tJSON.stringify(); \n')])])]),a("h3",{attrs:{id:"_3-json文件存在的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-json文件存在的意义"}},[t._v("#")]),t._v(" 3.json文件存在的意义")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//模拟数据(与后端先商量)\n[\n\t{\n\t\t"id":"G001",\n\t\t"name":"Thermos 膳魔师 Funtainer系列水杯 12盎司（340g） 粉红色",\n\t\t"imgurl":"images/g1.jpg",\n\t\t"price":899,\n\t}\n]\n')])])]),a("h2",{attrs:{id:"三、ajax请求步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、ajax请求步骤"}},[t._v("#")]),t._v(" 三、Ajax请求步骤")]),t._v(" "),a("p",[t._v("1.创建请求对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var xhr = new XMLHttpRequest();//返回一个异步请求对象\n")])])]),a("p",[t._v("2.处理服务器返回数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("xhr.onreadystatechange = function(){\n    if(xhr.readyState == 4) {\n        //responseText：保存服务器返回的数据（从服务器返回的数据是“字符串”）。\n        alert(xhr.responseText);\n    }\n}\n")])])]),a("p",[t._v("3.设置请求参数,建立与服务器的连接")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('xhr.open("get", "http://localhost/api/ajaxtest", true);\n')])])]),a("p",[t._v("4.向服务器发送请求")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("xhr.send(null);\n")])])]),a("h2",{attrs:{id:"四、xmlhttprequest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、xmlhttprequest"}},[t._v("#")]),t._v(" 四、XMLHttpRequest")]),t._v(" "),a("h3",{attrs:{id:"_1-open-type-url-async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-open-type-url-async"}},[t._v("#")]),t._v(" 1.open(type,url,async)")]),t._v(" "),a("p",[t._v("open(type,url（同源策略）,async（同步、异步）)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.open(type,url,async): 建立与服务器的连接\n    type：请求的类型，get获取、post发送\n    \t* 区别? \n    \t\tget请求数据接在url后面，post请求数据通过send方法传递\n    \t\tget传递的数据会比较少，post没有限制\n    \t\tget传递的数据会暴露出来\n    url：数据请求的地址（API地址），一般由后端开发人员提供\n    \t* 相对路径的情况下，必须在同一个根目录(端口配置的目录)下。\n        * 当前页面访问地址，API地址两者一定要同域\n        * 同域（同源策略）：协议，域名，端口三者一致\n        * 报错： No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.\n\tasync：是否异步发送请求（true,false），默认为true\n        * 同步：按步骤顺序执行，前面的代码执行完后，后面的代码才会执行\n        \t做完前一件事情, 才能下一件事情（排队）\n        * 异步：与其他操作同时执行，也叫并发（图片加载，ajax请求，定时器）\n")])])]),a("h3",{attrs:{id:"_2-send-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-send-data"}},[t._v("#")]),t._v(" 2.send(data)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2.send(data): 向服务器发送请求\n\tdata：可选参数，post请求时才生效，表示发请求时传送的数据字符串。\n    \t xhr.send('size=20&type=music');\n\t\t在某些浏览器中，如果不需要通过post请求主体发送数据，则必须传入null\n//备注：get请求的数据写在url地址后\n\trequest.open(\"get\", \"http://localhost/api/getdata.php?type=get&qty=10\", true);\n\tsetRequestHeader(key,val)：设置请求头\n//备注：利用请求头设置POST提交数据格式(form表单)：\n\txhr.setRequestHeader('content-type','application/x-www-form-urlencoded');//open方法后设置\n")])])]),a("p",[t._v("在请求收到服务器的响应后，响应的数据会自动填充xhr 对象的属性，相关的属性简介如下")]),t._v(" "),a("h3",{attrs:{id:"_3-readystate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-readystate"}},[t._v("#")]),t._v(" 3.readyState")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("0 － （未初始化）尚未调用open()方法。\n1 － （启动）已经调用open()方法，但尚未调用send()方法。\n2 － （发送）send()方法执行完成，但尚未接收到响应。\n3 － （接收）已经接收到部分响应数据。\n4 － （完成）响应内容解析完成，可以在客户端调用了\n只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。\n")])])]),a("h3",{attrs:{id:"_4-responsetext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-responsetext"}},[t._v("#")]),t._v(" 4.responseText")]),t._v(" "),a("p",[t._v("保存服务器返回的数据（从服务器返回的数据是“字符串”）。")]),t._v(" "),a("h3",{attrs:{id:"_5-status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-status"}},[t._v("#")]),t._v(" 5.status")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("* 响应的HTTP 状态。\n200（OK）：服务器成功返回了页面\n304（Not Modified）：数据与服务器相同，不需要重服务器请求（直接使用缓存的数据）\n400（Bad Request）：语法错误导致服务器不识别\n401（Unauthorized）：请求需要用户认证\n404（Not found）：请求地址不存在\n500（Internal Server Error）：服务器出错或无响应\n503（ServiceUnavailable）：由于服务器过载或维护导致无法完\n")])])]),a("h2",{attrs:{id:"五、跨域解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、跨域解决方案"}},[t._v("#")]),t._v(" 五、跨域解决方案")]),t._v(" "),a("h3",{attrs:{id:"_1-jsonp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-jsonp"}},[t._v("#")]),t._v(" 1.JSONP")]),t._v(" "),a("p",[t._v("原理：利用script标签能加载其他域名的js文件的原理,实现跨域数据请求")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("* JSONP 是JSON with padding（填充式JSON 或参数式JSON）的简写。\n* JSONP是一种可以绕过浏览器的安全限制，从不同的域请求数据的方法。\n* JSONP请求不是ajax请求，是利用script标签能加载其他域名的js文件的原理，来实现跨域数据的请求 \n* 局限性：\n  - 只能为get请求\n  - 接口必须有回调函数的执行\n")])])]),a("p",[t._v("案例练习1：使用script标签其他js文件调用本地js的某个函数;")]),t._v(" "),a("p",[t._v("案例练习2：使用script标签其他php文件调用本地js的未知名方法，返回数据")]),t._v(" "),a("p",[t._v("案例练习3：利用JSONP原理调用百度建议")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("msg.oninput = function(){\n    let _msg = msg.value;\n    clearTimeout(timer);\n    timer = setTimeout(()=>{\n    let script = document.createElement('script');\n    script.src='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/sujson=1&cb=getData&wd='+_msg;\n    document.body.appendChild(script);\n    },500);\n}\nwindow.getData = function(data){\n    suggest.innerHTML = data.s.map(item=>{\n        return `<li>${item}</li>`\n        }).join(\"\");\n    }\n})\n//原理性代码：\n//1.script的src中回调函数的传递\nscript.src='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/sujson=1&cb=getData&wd='+_msg;\n//2.声明全局函数\nwindow.getData = function(data){处理数据}\n")])])]),a("h3",{attrs:{id:"_2-cors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-cors"}},[t._v("#")]),t._v(" 2.CORS")]),t._v(" "),a("p",[t._v("原理：在后端响应头添加词字段header('Access-Control-Allow-Origin: *')")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing），它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。服务器需要设置响应头，允许该域名访问\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.Access-Control-Allow-Origin\n\theader('Access-Control-Allow-Origin: *');  \n该字段是必须的。需要在后端响应头添加词字段，值要么是一个*，表示接受任意域名的请求，要么指定一个域名http://localhost。\n2.Access-Control-Allow-Methods\n3.Access-Control-Allow-Headers\n    header('Access-Control-Allow-Methods:POST');  \n    header('Access-Control-Allow-Headers:x-requested-with,content-type'); \n")])])]),a("p",[t._v("案例1：天气预报")]),t._v(" "),a("p",[t._v("案例2：百度地图")]),t._v(" "),a("h3",{attrs:{id:"_3-服务器代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务器代理"}},[t._v("#")]),t._v(" 3.服务器代理")]),t._v(" "),a("p",[t._v("原理：file_get_contents($url) //获取网站内容")]),t._v(" "),a("p",[t._v("后端不存在跨域问题，所以可以利用后端间接获取其他网站的数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ajax跨域请求之服务端代理（爬虫）\n原理：获取页面所有内容，并利用正则匹配所需内容\nfile_get_contents($url) //获取网站内容\npreg_match_all($reg,$str,$res) \npreg_match($reg,$str,$res)   //$str代表被匹配的内容，$res为结果\n$content = iconv(原字符编码,新字符编码,$content);//修改$content字符编码\n")])])]),a("p",[t._v("案例1：利用服务器代理获取外网IP")]),t._v(" "),a("p",[t._v("案例2：根据IP获取所在城市（ajax嵌套）")]),t._v(" "),a("p",[t._v("案例3：根据城市获取天气预报（ajax嵌套）")]),t._v(" "),a("p",[t._v("案例4：POST请求数据")]),t._v(" "),a("h2",{attrs:{id:"六、异步处理方法promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、异步处理方法promise"}},[t._v("#")]),t._v(" 六、异步处理方法Promise")]),t._v(" "),a("h3",{attrs:{id:"_1-promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-promise"}},[t._v("#")]),t._v(" 1.Promise")]),t._v(" "),a("p",[t._v("Promise是一个构造函数，所谓的Promise对象，就是通过new Promise()实例化得到的对象，用来传递异步操作的数据。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。")]),t._v(" "),a("p",[t._v("1.创建对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var p=new Promise(function(resolve,reject){\n    //成功拿到数据执行resolve,失败执行reject\n})\n\t*规定好了哪个阶段执行哪个函数\nPromise的三种状态\n    * Pending(未完成)可以理解为Promise对象实例new创建时候的初始状态\n    * Resolved(成功)可以理解成功的状态\n    * Rejected(失败)可以理解为失败的状态\n")])])]),a("p",[t._v("2.执行方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("p.then(成功时要执行的代码).catch(失败时执行的代码)\n")])])]),a("p",[t._v("3.静态方法")]),t._v(" "),a("p",[t._v("Promise.all([p1,p2,p3,p4])")]),t._v(" "),a("p",[t._v("将多个Promise实例,包装成一个新的Promise实例")]),t._v(" "),a("p",[t._v("所有参数中的Promise状态都为resolved时,新的promise状态才为resolved")]),t._v(" "),a("p",[t._v("只要p1,p2,p3...之中有一个被rejected,新的promise的状态就变成rejected")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Promise.all([p1,p2,p3]).then(function(res){\n\tconsole.log(res);\n})\n")])])]),a("p",[t._v("Promise.race([p1,p2,p3...]) 竞速,完成一个即可")]),t._v(" "),a("h3",{attrs:{id:"_2-try-catch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-try-catch"}},[t._v("#")]),t._v(" 2.try...catch")]),t._v(" "),a("p",[t._v("尝试执行代码,如果有错误则执行catch捕获错误(不报错)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("try{\n\tconsole.log(666)\n\t//先尝试执行这里的代码\n\tshow();\n\t//无报错，则忽略catch\n\t//如果报错，则执行catch，并传递错误信息\n}catch(error){\n\tconsole.log(error)\n}\nconsole.log('end');\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);